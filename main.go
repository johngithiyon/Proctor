package main

import (
    "encoding/base64"
    "encoding/json"
    "fmt"
    "html/template"
    "io/ioutil"
    "net/http"
    "net/url"
    "os"
    "path/filepath"
    "strings"
    "sync"
)

var templates = template.Must(template.ParseGlob("templates/*.html"))

// --- User and Data Structures ---
var studentUser = map[string]string{
    "student1": "1234",
}
var adminUser = map[string]string{
    "admin": "admin123",
}
var exams = []string{
    "Math Exam - Grade 10",
    "Science Exam - Grade 10",
}

type Result struct {
    Username string
    Score    int
}

type Violation struct {
    Username string
    Count    int
}

type Student struct {
    Username string
}

var results []Result
var violations []Violation
var students []Student
var mu sync.Mutex

// Store reference faces for each user
var userReferenceFaces = make(map[string]string)

func main() {
    os.MkdirAll("captured_images", os.ModePerm)
    os.MkdirAll("reference_faces", os.ModePerm)
    os.MkdirAll("templates", os.ModePerm)

    // Load existing students from reference_faces directory
    loadExistingStudents()

    http.HandleFunc("/", loginPage)
    http.HandleFunc("/login", loginHandler)
    http.HandleFunc("/exam", examPage)
    http.HandleFunc("/proctor", proctorPage)
    http.HandleFunc("/capture", captureHandler)
    http.HandleFunc("/submit", submitHandler)
    http.HandleFunc("/score", scorePage)
    http.HandleFunc("/admin", adminPage)
    http.HandleFunc("/add-student", addStudentHandler)
    http.HandleFunc("/delete-student", deleteStudentHandler)
    http.HandleFunc("/reference-images/", serveReferenceImage)
    http.HandleFunc("/fullscreen-violation", fullscreenViolationHandler)
    http.HandleFunc("/tab-change-violation", tabChangeViolationHandler)
    http.HandleFunc("/window-change-violation", windowChangeViolationHandler)
    http.HandleFunc("/validate-face", validateFaceHandler)
    fmt.Println("Server running on http://localhost:8080")
    http.ListenAndServe(":8080", nil)
}

// Load existing students from reference_faces directory
func loadExistingStudents() {
    mu.Lock()
    defer mu.Unlock()

    files, err := ioutil.ReadDir("reference_faces")
    if err != nil {
        return
    }

    for _, file := range files {
        if !file.IsDir() && strings.HasSuffix(file.Name(), ".jpg") {
            username := strings.TrimSuffix(file.Name(), ".jpg")
            students = append(students, Student{Username: username})
            userReferenceFaces[username] = filepath.Join("reference_faces", file.Name())
        }
    }
}

// --- Page Renderers ---
func loginPage(w http.ResponseWriter, r *http.Request) {
    templates.ExecuteTemplate(w, "login.html", nil)
}

func examPage(w http.ResponseWriter, r *http.Request) {
    username := r.URL.Query().Get("user")
    data := struct {
        Username string
        Exams    []string
    }{username, exams}
    templates.ExecuteTemplate(w, "exam.html", data)
}

// --- FIX: Updated proctorPage to handle the exam name ---
// This function now correctly receives the 'exam' query parameter from the URL
// generated by the new exam.html page and passes it to the proctor.html template.
func proctorPage(w http.ResponseWriter, r *http.Request) {
    username := r.URL.Query().Get("user")
    exam := r.URL.Query().Get("exam")

    data := struct {
        Username string
        Exam     string
    }{username, exam}

    templates.ExecuteTemplate(w, "proctor.html", data)
}

func scorePage(w http.ResponseWriter, r *http.Request) {
    username := r.URL.Query().Get("user")
    var studentScore int
    mu.Lock()
    for _, res := range results {
        if res.Username == username {
            studentScore = res.Score
            break
        }
    }
    mu.Unlock()
    templates.ExecuteTemplate(w, "score.html", struct {
        Username string
        Score    int
    }{username, studentScore})
}

func adminPage(w http.ResponseWriter, r *http.Request) {
    mu.Lock()
    defer mu.Unlock()

    type AdminData struct {
        Results    []Result
        Violations []Violation
        Students   []Student
    }

    data := AdminData{
        Results:    results,
        Violations: violations,
        Students:   students,
    }

    templates.ExecuteTemplate(w, "admin.html", data)
}

// --- Handlers ---
func loginHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        http.Redirect(w, r, "/", http.StatusSeeOther)
        return
    }

    username := r.FormValue("username")
    password := r.FormValue("password")
    role := r.FormValue("role")
    faceValidated := r.FormValue("face_validated")

    // Validate credentials
    if role == "student" {
        if pass, ok := studentUser[username]; !ok || pass != password {
            templates.ExecuteTemplate(w, "login.html", "Invalid credentials!")
            return
        }

        // Check if reference face exists for this student
        mu.Lock()
        _, exists := userReferenceFaces[username]
        mu.Unlock()

        if !exists {
            templates.ExecuteTemplate(w, "login.html", "No reference image found for this student. Please contact the admin.")
            return
        }
    } else if role == "admin" {
        if pass, ok := adminUser[username]; !ok || pass != password {
            templates.ExecuteTemplate(w, "login.html", "Invalid credentials!")
            return
        }
        // Admin doesn't need face verification
        http.Redirect(w, r, "/admin", http.StatusSeeOther)
        return
    }

    // Check if face was validated
    if faceValidated != "true" {
        templates.ExecuteTemplate(w, "login.html", "Face validation failed. Please try again.")
        return
    }

    // For students, we don't save the face image as it's already captured by admin
    // We just validate it against the reference image
    if role == "student" {
        // Redirect to exam page
        http.Redirect(w, r, "/exam?user="+username, http.StatusSeeOther)
    } else {
        templates.ExecuteTemplate(w, "login.html", "Please capture your face photo!")
    }
}

// Add student handler
func addStudentHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }

    username := r.FormValue("username")
    password := r.FormValue("password")
    faceImage := r.FormValue("face_image")

    // Check if username already exists
    mu.Lock()
    if _, exists := studentUser[username]; exists {
        mu.Unlock()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"success": "false", "message": "Username already exists"})
        return
    }

    // Add student to the system
    studentUser[username] = password
    students = append(students, Student{Username: username})
    mu.Unlock()

    // Handle captured face image
    if faceImage == "" {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"success": "false", "message": "No face image provided"})
        return
    }

    // Decode base64 image
    parts := strings.Split(faceImage, ",")
    if len(parts) != 2 {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"success": "false", "message": "Invalid face image format"})
        return
    }

    decoded, err := base64.StdEncoding.DecodeString(parts[1])
    if err != nil {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"success": "false", "message": "Error decoding face image"})
        return
    }

    // Save the reference image
    referenceFacePath := filepath.Join("reference_faces", username+".jpg")
    err = ioutil.WriteFile(referenceFacePath, decoded, 0644)
    if err != nil {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"success": "false", "message": "Error saving face image"})
        return
    }

    // Store reference face path for this user
    mu.Lock()
    userReferenceFaces[username] = referenceFacePath
    mu.Unlock()

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{"success": "true", "message": "Student added successfully"})
}

// Delete student handler
func deleteStudentHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }

    username := r.FormValue("username")

    mu.Lock()
    defer mu.Unlock()

    // Remove from studentUser map
    delete(studentUser, username)

    // Remove from userReferenceFaces map
    if referenceFacePath, exists := userReferenceFaces[username]; exists {
        // Delete the reference image file
        os.Remove(referenceFacePath)
        delete(userReferenceFaces, username)
    }

    // Remove from students slice
    for i, student := range students {
        if student.Username == username {
            students = append(students[:i], students[i+1:]...)
            break
        }
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{"success": "true", "message": "Student deleted successfully"})
}

// Serve reference image
func serveReferenceImage(w http.ResponseWriter, r *http.Request) {
    // Extract username from URL path
    path := strings.TrimPrefix(r.URL.Path, "/reference-images/")
    if path == "" {
        http.NotFound(w, r)
        return
    }

    // Add .jpg extension if not present
    if !strings.HasSuffix(path, ".jpg") {
        path = path + ".jpg"
    }

    // Construct the full path to the image
    imagePath := filepath.Join("reference_faces", path)

    // Check if file exists
    if _, err := os.Stat(imagePath); os.IsNotExist(err) {
        http.NotFound(w, r)
        return
    }

    // Serve the image
    http.ServeFile(w, r, imagePath)
}

// Validate face in the captured image
func validateFaceHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        w.WriteHeader(http.StatusBadRequest)
        return
    }

    imgData := r.FormValue("image")
    username := r.FormValue("username")

    if imgData == "" {
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte("ERROR: No image provided"))
        return
    }

    // If username is provided, check against reference face
    if username != "" {
        // Get reference face path for this user
        mu.Lock()
        referenceFacePath, exists := userReferenceFaces[username]
        mu.Unlock()

        if !exists {
            w.WriteHeader(http.StatusInternalServerError)
            w.Write([]byte("ERROR: No reference face found for user"))
            return
        }

        // Forward the image to the Python service for face validation
        resp, err := http.PostForm("http://localhost:5000/validate-face", url.Values{
            "image":          {imgData},
            "reference_face": {referenceFacePath},
        })
        if err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            w.Write([]byte("ERROR"))
            return
        }
        defer resp.Body.Close()

        body, _ := ioutil.ReadAll(resp.Body)
        responseStr := string(body)

        if responseStr == "FACE_MATCH" {
            w.Write([]byte("FACE_MATCH"))
        } else {
            w.Write([]byte("NO_FACE_MATCH"))
        }
    } else {
        // Just check if a face is detected (for admin capture)
        resp, err := http.PostForm("http://localhost:5000/validate-face", url.Values{
            "image": {imgData},
        })
        if err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            w.Write([]byte("ERROR"))
            return
        }
        defer resp.Body.Close()

        body, _ := ioutil.ReadAll(resp.Body)
        responseStr := string(body)

        if responseStr == "FACE_DETECTED" {
            w.Write([]byte("FACE_DETECTED"))
        } else {
            w.Write([]byte("NO_FACE_DETECTED"))
        }
    }
}

// Forward captured data to Python OpenCV service
func captureHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        w.WriteHeader(http.StatusBadRequest)
        return
    }

    imgData := r.FormValue("image")
    username := r.FormValue("username")
    noiseViolation := r.FormValue("noise_violation")

    // Get reference face path for this user
    mu.Lock()
    referenceFacePath, exists := userReferenceFaces[username]
    mu.Unlock()

    if !exists {
        w.WriteHeader(http.StatusInternalServerError)
        w.Write([]byte("ERROR: No reference face found for user"))
        return
    }

    resp, err := http.PostForm("http://localhost:5000/capture", url.Values{
        "image":           {imgData},
        "username":        {username},
        "noise_violation": {noiseViolation},
        "reference_face":  {referenceFacePath},
    })
    if err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        w.Write([]byte("ERROR"))
        return
    }
    defer resp.Body.Close()
    body, _ := ioutil.ReadAll(resp.Body)

    responseStr := string(body)

    // Handle specific termination messages
    if responseStr == "FACE_MISMATCH" {
        w.Write([]byte("FACE_MISMATCH"))
        return
    }

    // Handle multiple faces detection
    if responseStr == "MULTIPLE_FACES" {
        w.Write([]byte("MULTIPLE_FACES"))
        return
    }

    // Handle violations, including the new PROHIBITED_ITEM type
    // FIXED: Check if response already starts with "VIOLATION:" and pass it through directly
    if strings.HasPrefix(responseStr, "VIOLATION:") {
        // Parse the violation response to extract the count
        respParts := strings.Split(responseStr, ":")
        if len(respParts) >= 3 {
            // Extract the count from the response
            countStr := respParts[len(respParts)-1]
            count := 0
            fmt.Sscanf(countStr, "%d", &count)
            
            // Update the violation count in the database
            mu.Lock()
            found := false
            for i, v := range violations {
                if v.Username == username {
                    if count > violations[i].Count {
                        violations[i].Count = count
                    }
                    found = true

                    if violations[i].Count >= 10 {
                        mu.Unlock()
                        w.Write([]byte("MAX_VIOLATIONS"))
                        return
                    }
                    break
                }
            }

            if !found {
                violations = append(violations, Violation{Username: username, Count: count})
            }
            mu.Unlock()
            
            // Pass through the original response from Python service
            w.Write([]byte(responseStr))
            return
        }
    }

    // Pass through any other response (like "OK")
    w.Write(body)
}

// Handle fullscreen violation
func fullscreenViolationHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        w.WriteHeader(http.StatusBadRequest)
        return
    }

    username := r.FormValue("username")

    mu.Lock()
    found := false
    for i, v := range violations {
        if v.Username == username {
            violations[i].Count++
            found = true

            if violations[i].Count >= 10 {
                mu.Unlock()
                w.Write([]byte("MAX_VIOLATIONS"))
                return
            }

            w.Write([]byte(fmt.Sprintf("VIOLATION:FULLSCREEN_VIOLATION:%d", violations[i].Count)))
            mu.Unlock()
            return
        }
    }

    if !found {
        violations = append(violations, Violation{Username: username, Count: 1})
        w.Write([]byte(fmt.Sprintf("VIOLATION:FULLSCREEN_VIOLATION:1")))
    }
    mu.Unlock()
}

// Handle tab change violation
func tabChangeViolationHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        w.WriteHeader(http.StatusBadRequest)
        return
    }

    username := r.FormValue("username")

    mu.Lock()
    found := false
    for i, v := range violations {
        if v.Username == username {
            violations[i].Count++
            found = true

            if violations[i].Count >= 10 {
                mu.Unlock()
                w.Write([]byte("MAX_VIOLATIONS"))
                return
            }

            w.Write([]byte(fmt.Sprintf("VIOLATION:TAB_CHANGE_VIOLATION:%d", violations[i].Count)))
            mu.Unlock()
            return
        }
    }

    if !found {
        violations = append(violations, Violation{Username: username, Count: 1})
        w.Write([]byte(fmt.Sprintf("VIOLATION:TAB_CHANGE_VIOLATION:1")))
    }
    mu.Unlock()
}

// Handle window change violation
func windowChangeViolationHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        w.WriteHeader(http.StatusBadRequest)
        return
    }

    username := r.FormValue("username")

    mu.Lock()
    found := false
    for i, v := range violations {
        if v.Username == username {
            violations[i].Count++
            found = true

            if violations[i].Count >= 10 {
                mu.Unlock()
                w.Write([]byte("MAX_VIOLATIONS"))
                return
            }

            w.Write([]byte(fmt.Sprintf("VIOLATION:WINDOW_CHANGE_VIOLATION:%d", violations[i].Count)))
            mu.Unlock()
            return
        }
    }

    if !found {
        violations = append(violations, Violation{Username: username, Count: 1})
        w.Write([]byte(fmt.Sprintf("VIOLATION:WINDOW_CHANGE_VIOLATION:1")))
    }
    mu.Unlock()
}

func submitHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        w.WriteHeader(http.StatusBadRequest)
        return
    }

    username := r.FormValue("username")
    score := r.FormValue("score")

    var sc int
    fmt.Sscanf(score, "%d", &sc)

    mu.Lock()
    results = append(results, Result{Username: username, Score: sc})
    mu.Unlock()

    http.Redirect(w, r, "/score?user="+username, http.StatusSeeOther)
}